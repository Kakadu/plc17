\documentclass[10pt]{article}

\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}

\newcommand{\code}{\texttt}

\title{Уменьшение цены абстракции при типобезопасном встраивании реляционного языка программирования в OCaml}
\author{
        Дмитрий Косарев\\ \texttt{Dmitrii.Kosarev@protonmail.ch}
%             \and
%         Дмитрий Косарев\\ \texttt{Dmitrii.Kosarev@protonmail.ch}
        %% Санкт-Петербургский государственный университет\\
        %% Математико-механический факультет
}
\date{
  Санкт-Петербургский государственный университет\\
  Математико-механический факультет\\
  \today
}

\begin{document}
\maketitle

\begin{abstract}
В данной работе затронуты детали OCanren -- типобезопасной реализации реляционного языка программирования
из семейства miniKanren на OCaml, а именно два подхода для организации типов логических значений. Первый,
наивный подход позволил получить типобезопасную реализацию, однако, он привел к понижению производительности
на стадии унификации (unification) про сравнению с реализацией $\mu$Kanren на Racket. Второй подход не 
страдает этим недостатком.

\end{abstract}

\textbf{Ключевые слова:} OCaml, miniKanren, реляционное программирование, унификация, цена абстракции.

\vspace{5mm}

Реляционный язык программирования miniKanren
%\cite{miniKanren} 
позволяет записывать программы как формулы, состоящие из отношений
(relations). Относительная простота miniKanren привела к появлению целого семейства реализаций, большинство их 
которых были сделаны на различных диалектах LISP, либо на типизируемых языках в бестиповой манере. OCanren\cite{OCanren} 
является типизированной реализацией $\mu$Kanren\cite{uKanren} (одной из наиболее минималистичных реализаций miniKanren) 
на OCaml -- языке программирования со строгой статической типизацией.

В OCanren разрешается унифицировать между собой только те логические переменные и значения, которые инкапсулируют
значения одинакового типа. Это позволяет находить на стадии компиляции случаи, при которых унифицируются 
значения разных типов, и, следовательно, унификация не может завершиться успешно ни при каких условиях. Также
компилятор, теоретически, может генерировать вызов специализированной для конкретного типа унификации, вместо 
обобщенной.

При создании новой реализации miniKanren необходимо обдумать два аспекта: в каком порядке будут вычисляться 
результаты (порядок поиска), и как именно будет происходить процесс унификации. В OCanren была реализована истинно 
полиморфная унификация: одна функция позволяет унифицировать любые значения одинаковых типов. Унификация производится
путём сравнения ориентированных графов (в случае miniKanren -- деревьев), т.к. все значения OCaml хранятся в 
памяти именно в таком виде.

Однако, наивный подход связанный с объявлением алгебраического типа логических значений, который содержит в себе 
либо логические переменные (конструктор $Var$), либо обычные значения (конструктор $Value$), приводит к тому, что 
размер представлений (деревьев) значений в памяти увеличивается. 
Например, целые числа типа int хранятся в виде одного блока памяти. Логическое представление для этих чисел
будет состоять из двух блоков памяти: для конструктора $Value$ и непосредственно для числа, тем самым увеличивая 
высоту дерева представления в два раза: с единицы до двух.

Для списков (и других \emph{рекурсивных} структур данных) высота деревьев также увеличивается в два раза. Например,
список чисел из одного элемента будет занимать в памяти три блока и образовывать дерево высотой два. Логический
эквивалент такого же списка будет пердставляться в памяти деревом размером 6 и высотой 4, что будет сказывается 
на производительности унификации. Таким образом, общая производительность OCanren оказывается в разы меньше чем 
изначальный вариант.

Другой испробованный подход не использует конструктор  $Value$ для создания логических значений, хотя это требует 
больше небезопасных приведений типов в ядре OCanren. Но при этом OCanren не требует небезопасных приведений типов
в клиентском коде, что позволяет писать в целом типобезопасные программы. Данный подход 
требует некоторых преобразований получившихся значений, если они содержат в себе свободные логические переменные. Однако, 
эти преобразования происходят один раз в конце вычислений и влияют на производительность существенно меньшим образом.
Таким образом, при втором подходе не появляется дополнительных блоков памяти в представлении данных, следовательно размер 
деревьев не увеличивается, производительность унификации увеличивается по сравнению с первым случаем, а цена абстракции 
при переписывании кода на типизированный язык уменьшается.

\begin{thebibliography}{99}

\bibitem{uKanren}
Jason Hemann, Daniel P. Friedman. $\mu$Kanren: A Minimal Core for Relational Programming //
Proceedings of the 2013 Workshop on Scheme and Functional Programming (Scheme '13).

\bibitem{OCanren}
Dmitrii Kosarev, Dmitri Boulytchev. Typed Embedding of a Relational Language in OCaml //
Workshop on ML, 2016.
 
\end{thebibliography}

\end{document}
