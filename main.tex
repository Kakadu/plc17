\documentclass[10pt]{article}

\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}

\newcommand{\code}{\texttt}

\title{Независимая от компилятора библиотека точной сборки мусора для языка C++}
\author{
        Евгений Моисеенко\\ \texttt{evg.moiseenko94@gmail.com}
            \and
        Даниил Березун\\ \texttt{danya.berezun@gmail.com}
        %% Санкт-Петербургский государственный университет\\
        %% Математико-механический факультет
}
\date{
  Санкт-Петербургский государственный университет\\
  Математико-механический факультет\\
  \today
}

\begin{document}
\maketitle

\begin{abstract}
В данной работе представлен подход к сборке мусора для языка C++, основанный на использовании умных указателей.
Реализованный алгоритм сборки мусора является точным и не требует поддержки со стороны компилятора,
может работать с многопоточными приложениями,
а также поддерживает сжатие и параллельную маркировку (\emph{concurrent marking}).
Представленный в работе подход позволяет совмещать использование 
трассирующего сборщика мусора с другими методами управления памятью в C++, 
в том числе с ручным управлением памятью и методами основанными на использовании
умных указателей \code{std::unique\_ptr} и \code{std::shared\_ptr}. 

\end{abstract}

\textbf{Ключевые слова:} C++, динамическое управление памятью, сборка мусора.

\vspace{5mm}

Большинство современных языков программирования активно использует \emph{динамическое распределение памяти}, 
при котором выделение памяти осуществляется во время исполнения программы. 
\emph{Автоматическое управление памятью} избавляет программиста от необходимости 
вручную освобождать выделенную память, 
устраняя тем самым целый класс возможных ошибок и 
увеличивая безопасность исходного кода программы. 


Язык C++ разрабатывался с расчетом на использование ручного управления памятью.
Тем не менее, в последние годы прослеживается тенденция к добавлению в язык 
средств автоматического управления памятью. 
Так, в стандартную библиотеку С++11 были добавлены 
умные указатели \code{std::unique\_ptr} и \code{std::shared\_ptr}. 
Первый реализует управление памятью на основе \emph{уникального владения ресурсом},
а второй использует \emph{подсчёт ссылок}. 

Оба подхода имеют свои ограничения и недостатки. 
Например, \\\code{std::shared\_ptr} не может быть использован 
в структурах данных с циклическими ссылками.
Для разрешения циклических зависимостей предлагается использовать  
класс \emph{невладеющего} указателя --- \code{std::weak\_ptr}.
То есть, ответственность за разрешение циклических зависимостей 
перекладывается на программиста. 

Таким образом, наличие трассирующей сборки мусора в C++
могло бы стать полезным инструментом в случае, 
когда другие методы автоматического управления памятью 
не могут быть использованы в силу их ограничений.

В нашей работе представлена реализация \emph{трассирующей сборки мусора} 
для языка C++ на уровне библиотеки. 
Пользователю библиотеки предоставляется набор примитивов, 
в том числе класс умного указателя \code{gc\_ptr} для хранения
указателей на управляемые объекты и 
функция \code{gc\_new} для создания управляемых объектов в куче.

Насколько нам известно, наше решение является первым
полностью точным трассирующим сборщиком мусора для C++.
Для решения проблемы \emph{утечки умных указателей}
мы добавили в библиотеку новый примитив \code{gc\_pin},
который служит для отслеживания разыменованных указателей
и закрепления объектов, на которые они указывают 
(под закреплением подразумевается запрет на перемещение объекта 
сборщиком мусора). При каждом явном или неявном разыменовании \code{gc\_ptr}
создается объект \code{gc\_pin}. 

Для хранения управляемых объектов используется собственная реализация кучи.
Поддерживается \emph{сжатие} кучи для уменьшения \emph{фрагментации} памяти.
Наш сборщик выполняет \emph{остановку мира} (т.е. приостановку приложения)
для сборки мусора. 
Также поддерживается \emph{параллельная маркировка} (\emph{concurrent marking}).
Пользователь библиотеки может активировать эту опцию,
в этом случае фаза маркировки проходит параллельно с работой приложения, 
без необходимости его приостановки. 
Параллельная маркировка уменьшает время паузы на сборку мусора, 
однако дополнительные накладные расходы на синхронизации приложения и сборщика
могут увеличить суммарное время работы.

Предложенный в работе подход не лишен недостатков. 
Вследствие отказа от какого либо взаимодействия с компилятором
сборщику мусора приходится поддерживать множество структур данных и выполнять 
множество проверок во время исполнения программы, 
что приводит к увеличению времени работы приложения.
Стоит отметить, что производительность кода не взаимодействующего со сборщиком не изменится, 
что вполне соответствует одному из принципов С++ --- ``don’t pay for what you don’t use''.
Кроме того, сборщик мусора не может разрешить циклические зависимости
между областями памяти, находящимися под управлением разных менеджеров памяти.

Таким образом, в нашей работе было показано, 
что использование богатых языковых возможностей C++ 
позволяет реализовать сборку мусора 
без поддержки со стороны компилятора или расширения языка.

%% \bibliographystyle{abbrv}
%% \bibliography{main}

\end{document}
