\documentclass[10pt]{article}

\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}

\newcommand{\code}{\texttt}

\title{Независимая от компилятора библиотека точной сборки мусора для языка C++}
\author{
        Евгений Моисеенко\\ \texttt{evg.moiseenko94@gmail.com}
            \and
        Даниил Березун\\ \texttt{danya.berezun@gmail.com}
        %% Санкт-Петербургский государственный университет\\
        %% Математико-механический факультет
}
\date{
  Санкт-Петербургский государственный университет\\
  Математико-механический факультет\\
  \today
}

\begin{document}
\maketitle

\begin{abstract}
В данной работе представлен сборщик мусора для языка C++.
Представленный сборщик мусора является точным и не требует поддержки со стороны компилятора,
может работать с многопоточными приложениями,
а также поддерживает сжатие и параллельную маркировку (\emph{concurrent marking}).
Библиотека определяет класс умного указателя --- \code{gc\_ptr}.
Представленный в работе подход позволяет совмещать использование 
трассирующего сборщика мусора с другими методами управления памятью в C++, 
в том числе с ручным управлением памятью и методами основанными на использовании
умных указателей \code{std::unique\_ptr} и \code{std::shared\_ptr}. 

\end{abstract}

Большинство современных языков программирования активно использует \emph{динамическое распределение памяти}, 
при котором выделение памяти осуществляется во время исполнения программы. 
\emph{Автоматическое управление памятью} избавляет программиста от необходимости 
вручную освобождать выделенную память, 
устраняя тем самым целый класс возможных ошибок и 
увеличивая безопасность исходного кода программы. 

%% Различают два подхода к автоматическому управлению памятью --- 
%% \emph{подсчёт ссылок} и \emph{трассирующиую сборку мусора}.
%% При подсчете ссылок с каждым объектом в куче связывается целое число --- счетчик ссылок. 
%% Когда количество ссылок становится равным нулю память, занимаемая объектом, 
%% может быть освобождена.
%% Трассирующая сборка мусора основана на использовании критерия доступности объекта. 
%% Область памяти называется \emph{доступной}, 
%% если либо указатель на неё принадлежит корневому множеству, 
%% либо существует указатель на неё из другой области памяти, являющейся доступной. 
%% \emph{Корневое множество} представляет собой множество априори доступных объектов. 
%% Конкретное определение корневого множества 
%% зависит от языка программирования и среды времени выполнения.  
%% Трассирующий сборщик мусора строит множество доступных в определенный момент 
%% работы программы объектов. 
%% Память, занимаемая недоступными объектами (называемая \emph{мусором}), 
%% может быть освобождена и переиспользована.

Язык C++ разрабатывался с расчетом на использование ручного управления памятью.
Тем не менее, в последние годы прослеживается тенденция к добавлению в язык 
средств автоматического управления памятью. 
Так, в стандартную библиотеку С++11 были добавлены 
умные указатели \code{std::unique\_ptr} и \code{std::shared\_ptr}. 
Первый реализует управление памятью на основе \emph{уникального владения ресурсом},
а второй использует \emph{подсчёт ссылок}. 

Оба подхода имеют свои ограничения и недостатки. 
Например, \\\code{std::shared\_ptr} не может быть использован 
в структурах данных с циклическими ссылками.
Для разрешения циклических зависимостей предлагается использовать  
класс \emph{невладеющего} указателя --- \code{std::weak\_ptr}.
Ответственность за разрешение циклических зависимостей 
таким образом перекладывается на программиста. 

Таким образом, наличие трассирующей сборки мусора в C++
могло бы стать полезным инструментом в случае, 
когда другие методы автоматического управления памятью 
не могут быть использованы в силу их ограничений.

В нашей работе представлена реализация \emph{трассирующей сборки мусора} 
для языка C++ на уровне библиотеки. 
Пользователю библиотеки предоставляется набор примитивов, 
в том числе класс умного указателя \code{gc\_ptr} для хранения
указателей на управляемые объекты и 
функция \code{gc\_new} для создания управляемых объектов в куче.

Насколько нам известно, наше решение является первым
полностью точным трассирующим сборщиком мусора для C++.
Для решения проблемы \emph{утечки умных указателей}
мы добавили в библиотеку новый примитив \code{gc\_pin},
который служит для отслеживания разыменовынных указателей
и закрепления объектов, на которые они указывают 
(под закреплением подразумевается запрет на перемещение объекта 
сборщиком мусора). При каждом явном или неявном разыменовании \code{gc\_ptr}
создается объект \code{gc\_pin}. 

Для хранения управляемых объектов используется собственная реализация кучи.
Поддерживается \emph{сжатие} кучи для уменьшения \emph{фрагментации} памяти.
Наш сборщик выполняет \emph{остановку мира} (т.е. приостановку приложения)
для сборки мусора. 
Также поддерживается \emph{параллельная маркировка} (\emph{concurrent marking}).
Пользователь библиотеки может активировать эту опцию,
в этом случае фаза маркировки проходит параллельно с работой приложения, 
без необходимости его приостановки. 
Параллельная маркировка уменьшает время паузы на сборку мусора, 
однако дополнительные накладные расходы на синхронизации приложения и сборщика
могут увеличить суммарное время работы.

К ограничениям нашего подхода можно отнести то,
что пользователь должен соблюдать ряд соглашений для корректной работы сборщика.

\begin{enumerate}
\item Пользователь должен использовать объекты класса \code{gc\_ptr} для хранения управляемых указателей и только их.
\item Пользователь должен использовать функцию \code{gc\_new} для создания управляемых объектов.
\item Существует возможность получить ``сырой'' указатель на управляемый объект с помощью \code{gc\_pin}. 
      Однако время жизни такого указателя не должно превышать время жизни соответствующего \code{gc\_pin}.
\end{enumerate}

Таким образом, в нашей работе было показано, 
что использование богатых языковых возможностей C++ 
позволяет реализовать инкрементальную сборку мусора 
без поддержки со стороны компилятора или расширения языка.

%% \bibliographystyle{abbrv}
%% \bibliography{main}

\end{document}
